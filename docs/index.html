<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>bSSFP Explorer — Sticky Controls (M0 fixed, Phase default)</title>
<!-- Local-first Plotly; put plotly.min.js next to this file for offline use -->
<script src="plotly.min.js"></script>
<!-- MathJax (deferred) -->
<script>
  window.MathJax = {
    tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$','$$'], ['\\[','\\]']], processEscapes: true },
    options: { renderActions: { addMenu: [] } }, svg: { fontCache: 'global' }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<style>
  :root{--bg:#121212;--panel:#1a1a1a;--ink:#e8e8ea;--muted:#a8abb2;--radius:16px;}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial;}
  header{padding:20px 16px 8px;text-align:center;}
  .title{font-weight:800;font-size:clamp(22px,3.5vw,36px);}
  .subtitle{color:var(--muted); font-size:14px; margin-top:6px;}
  .wrap{display:grid;gap:16px;grid-template-columns:320px 1fr;padding:14px;}
  @media(max-width:1100px){.wrap{grid-template-columns:1fr;}}
  .card{background:var(--panel);border-radius:var(--radius);border:1px solid rgba(255,255,255,.06);}
  .pad{padding:14px 14px 10px;}
  .section-title{font-weight:700;margin:4px 0 8px;}
  .hr{height:1px;background:rgba(255,255,255,.08);margin:10px 0;border:none;}
  .controls label{display:block;font-size:12px;color:var(--muted);margin:10px 0 4px;}
  .controls input[type="range"]{width:100%;}
  .controls input[type="number"]{width:120px;padding:6px 8px;border-radius:10px;border:1px solid rgba(255,255,255,.1);background:#141414;color:#fff;}
  .switch{display:inline-flex;align-items:center;gap:6px;background:#141414;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.1);font-size:12px;margin-right:8px;}
  .plot{height:420px;} .plotRF{height:300px;}
  .grid-heat-ellipse{display:grid;grid-template-columns:1.6fr 1fr;gap:12px;align-items:stretch;}
  @media(max-width:1100px){.grid-heat-ellipse{grid-template-columns:1fr;}}
  .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;color:#a0f0b3;}
  .msg{font-size:12px;color:var(--muted);margin-top:6px;}
  .warn{background:rgba(255,204,102,.1);border:1px solid rgba(255,204,102,.35);color:#ffdca3;padding:8px 12px;margin:8px 14px;border-radius:12px;display:none}

  /* Sticky controls while scrolling */
  .controls {
    position: sticky;
    top: 12px;
    align-self: start;
    max-height: calc(100vh - 24px);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  /* Subtle gray grids */
  :root { --grid: rgba(170,170,170,0.28); --zero: rgba(170,170,170,0.45);
          --ellipse:#666666; --dot:#ff7a00; }
</style>
</head>
<body>
<header>
  <div class="title">Balanced SSFP (bSSFP) — Explorer</div>
  <div class="subtitle">\( \alpha = \gamma B_1 \tau,\; \gamma = 2\pi \cdot 42.58\times 10^6\ \mathrm{rad/s/T} \). RF \(B_1(t)\) shown in μT. Here \(M_0\) is fixed to 1.</div>
</header>

<div id="warn" class="warn"></div>

<div class="wrap">
  <div class="card pad controls">
    <div class="section-title">Parameters</div>

    <label>Flip angle α (deg)</label>
    <input type="range" id="alpha" min="0" max="120" step="0.5" value="35" />
    <div><span class="kbd" id="alphaDisplay">35°</span></div>

    <label>TR (ms)</label>
    <input type="range" id="TR" min="2" max="12" step="0.1" value="4" />
    <div><span class="kbd" id="TRDisplay">4.0 ms</span></div>

    <label>RF pulse duration τ<sub>RF</sub> (ms)</label>
    <input type="range" id="tauRF" min="0.05" max="3.8" step="0.01" value="0.50" />
    <div><span class="kbd" id="tauRFDisplay">0.50 ms</span></div>

    <label>T<sub>1</sub> (ms)</label>
    <input type="range" id="T1" min="100" max="3000" step="10" value="1000" />
    <div><span class="kbd" id="T1Display">1000 ms</span></div>

    <label>T<sub>2</sub> (ms)</label>
    <input type="range" id="T2" min="10" max="300" step="1" value="80" />
    <div><span class="kbd" id="T2Display">80 ms</span></div>

    <label>RF phase increment φ (deg)</label>
    <input type="range" id="phi" min="0" max="360" step="1" value="180" />
    <div><span class="kbd" id="phiDisplay">180°</span></div>

    <label>Frequency range (×1/TR bandwidth)</label>
    <input type="range" id="fspan" min="0.2" max="3.0" step="0.1" value="1.0" />
    <div><span class="kbd" id="fspanDisplay">±0.50/TR</span></div>

    <div class="hr"></div>
    <div class="section-title">Display</div>
    <label class="switch"><input type="checkbox" id="showMag" checked /> |m|</label>
    <label class="switch"><input type="checkbox" id="showReal" /> Re</label>
    <label class="switch"><input type="checkbox" id="showImag" /> Im</label>
    <label class="switch"><input type="checkbox" id="showPhase" checked /> Phase</label>
  </div>

  <div class="card pad">
    <div class="section-title">RF waveform: \(B_1(t)\) — three TRs (μT)</div>
    <div id="plotRF" class="plotRF"></div>
    <div class="hr"></div>

    <div class="section-title">Lineshape vs off-resonance</div>
    <div id="plot1" class="plot"></div>
    <div class="hr"></div>

    <div class="section-title">Parameter sweep & complex-plane ellipse</div>
    <div class="grid-heat-ellipse">
      <div>
        <div style="font-size:13px;color:var(--muted);margin-bottom:6px;">|m| vs f and α (heatmap)</div>
        <div id="plot2" class="plot" style="height:460px;"></div>
      </div>
      <div>
        <div style="font-size:13px;color:var(--muted);margin-bottom:6px;">Ellipse of steady-state \(m\) (varying RF phase)</div>
        <div id="plotEllipse" class="plot" style="height:460px;"></div>
        <div id="ellipseMsg" class="msg"></div>
      </div>
    </div>
  </div>
</div>

<script>
"use strict";
const warnEl = document.getElementById('warn');
function warn(msg){ warnEl.textContent = msg; warnEl.style.display = 'block'; }

function ensurePlotly(){
  return new Promise((resolve)=>{
    if(window.Plotly){ return resolve(true); }
    const s=document.createElement('script');
    s.src='https://cdn.plot.ly/plotly-2.35.2.min.js';
    s.onload=()=>resolve(true);
    s.onerror=()=>{ warn('Could not load Plotly. Place plotly.min.js next to this HTML.'); resolve(false); };
    document.head.appendChild(s);
  });
}

const GRID = getComputedStyle(document.documentElement).getPropertyValue('--grid') || 'rgba(170,170,170,0.28)';
const ZERO = getComputedStyle(document.documentElement).getPropertyValue('--zero') || 'rgba(170,170,170,0.45)';
const ELLIPSE = getComputedStyle(document.documentElement).getPropertyValue('--ellipse') || '#666666';
const DOT = getComputedStyle(document.documentElement).getPropertyValue('--dot') || '#ff7a00';

const rad = d => d * Math.PI / 180;
function computeParams(TRms, T1ms, T2ms, alphaDeg, M0){
  const TR = TRms/1000, T1 = T1ms/1000, T2 = T2ms/1000;
  const TE = TR/2, E1 = Math.exp(-TR/T1), E2 = Math.exp(-TR/T2);
  const a = rad(alphaDeg), c = Math.cos(a), s = Math.sin(a);
  const D0 = 1 - E1*E2*E2 + (E2*E2 - E1)*c;
  const q = ((1 - E1)*E2*(1 + c)) / D0;
  const K = (M0*(1 - E1)*s) / D0 * Math.exp(-TE/T2);
  return {TR,T1,T2,TE,E1,E2,a,c,s,D0,q,K};
}

function computeSSFP(freqs, phiDeg, p){
  const {TR,TE,E2,q,K} = p;
  const phi = rad(phiDeg);
  const mag=[], real=[], imag=[], phs=[];
  for(let i=0;i<freqs.length;i++){
    const f=freqs[i], theta=2*Math.PI*f*TR, delta=phi - theta;
    const cosd=Math.cos(delta), sind=Math.sin(delta);
    const phaseP0=(TE/TR)*theta;
    const P0r=K*Math.cos(phaseP0), P0i=K*Math.sin(phaseP0);
    const nr=1 - E2*cosd, ni=-E2*sind, den=1 - q*cosd;
    const mr=(P0r*nr - P0i*ni)/den, mi=(P0r*ni + P0i*nr)/den;
    real[i]=mr; imag[i]=mi; mag[i]=Math.hypot(mr,mi); phs[i]=Math.atan2(mi,mr);
  }
  return {mag,real,imag,phs};
}

function computeM_for_phi(fHz, phiDeg, p){
  const {TR,TE,E2,q,K} = p;
  const theta=2*Math.PI*fHz*TR;
  const delta=rad(phiDeg) - theta;
  const c=Math.cos(delta), s=Math.sin(delta);
  const phaseP0=(TE/TR)*theta;
  const P0r=K*Math.cos(phaseP0), P0i=K*Math.sin(phaseP0);
  const den=1 - q*c, nr=1 - E2*c, ni=-E2*s;
  if(Math.abs(den) < 1e-12) return [NaN, NaN];
  const mr=(P0r*nr - P0i*ni)/den, mi=(P0r*ni + P0i*nr)/den;
  return [mr, mi];
}

function linspace(a,b,n){ const arr=new Array(n), step=(b-a)/(n-1); for(let i=0;i<n;i++) arr[i]=a + i*step; return arr; }

const els = {};
function bindEls(){
  // removed M0
  ['alpha','alphaDisplay','TR','TRDisplay','tauRF','tauRFDisplay','T1','T1Display','T2','T2Display','phi','phiDisplay','fspan','fspanDisplay','showMag','showReal','showImag','showPhase']
    .forEach(id => els[id]=document.getElementById(id));
  ['plotRF','plot1','plot2','plotEllipse','ellipseMsg'].forEach(id => els[id]=document.getElementById(id));
}

function clampTauRFMax(){
  const TRms=Number(els.TR.value);
  const maxVal=Math.max(0.05, TRms - 0.2);
  els.tauRF.max=String(maxVal);
  if(Number(els.tauRF.value)>maxVal) els.tauRF.value=String(maxVal.toFixed(2));
}
function updateDisplays(){
  els.alphaDisplay.textContent=`${Number(els.alpha.value).toFixed(1)}°`;
  els.TRDisplay.textContent=`${Number(els.TR.value).toFixed(1)} ms`;
  els.tauRFDisplay.textContent=`${Number(els.tauRF.value).toFixed(2)} ms`;
  els.T1Display.textContent=`${Number(els.T1.value)} ms`;
  els.T2Display.textContent=`${Number(els.T2.value)} ms`;
  els.phiDisplay.textContent=`${Number(els.phi.value)}°`;
  els.fspanDisplay.textContent=`±${(0.5*Number(els.fspan.value)).toFixed(2)}/TR`;
}

function computeRFSeries3(TRms, tauRFms, alphaDeg, phiIncDeg){
  const halfSpan=1.5*TRms, tStart=-halfSpan, tEnd=+halfSpan;
  const N=2400, t=linspace(tStart,tEnd,N);
  const centers=[-TRms,0,TRms];
  const phi_n=0, phi_nm1=(phi_n - phiIncDeg)%360, phi_np1=(phi_n + phiIncDeg)%360;
  const phiList=[phi_nm1, phi_n, phi_np1];
  const gamma=2*Math.PI*42.58e6; // rad/s/T
  const tau_s=Math.max(1e-9, tauRFms/1000);
  const alpha_rad=rad(alphaDeg);
  const amp_T=alpha_rad/(gamma*tau_s);
  const amp_uT=amp_T*1e6;
  const bx=new Array(N).fill(0), by=new Array(N).fill(0);
  const halfW=tauRFms/2;
  for(let i=0;i<N;i++){
    const ti=t[i];
    for(let k=0;k<3;k++){
      const c=centers[k];
      if(ti>=(c-halfW) && ti<(c+halfW)){
        const ph=rad(phiList[k]);
        bx[i]=amp_uT*Math.cos(ph); by[i]=amp_uT*Math.sin(ph); break;
      }
    }
  }
  return {t,bx,by,centers,tStart,tEnd,amp_uT,tauRFms};
}

function initFigures(){
  Plotly.newPlot(els.plotRF, [], {paper_bgcolor:'rgba(0,0,0,0)',plot_bgcolor:'rgba(0,0,0,0)',margin:{l:60,r:20,t:12,b:45},
    xaxis:{title:'Time (ms)', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
    yaxis:{title:'B1 (μT)', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO}}, {responsive:true});
  Plotly.newPlot(els.plot1, [], {paper_bgcolor:'rgba(0,0,0,0)',plot_bgcolor:'rgba(0,0,0,0)',margin:{l:60,r:60,t:10,b:45},
    xaxis:{title:'Off-resonance f (Hz)', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
    yaxis:{title:'Signal', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO}}, {responsive:true});
  Plotly.newPlot(els.plot2, [], {paper_bgcolor:'rgba(0,0,0,0)',plot_bgcolor:'rgba(0,0,0,0)',margin:{l:60,r:10,t:10,b:45},
    xaxis:{title:'Off-resonance f (Hz)', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
    yaxis:{title:'Flip angle α (deg)', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO}}, {responsive:true});
  Plotly.newPlot(els.plotEllipse, [], {paper_bgcolor:'rgba(0,0,0,0)',plot_bgcolor:'rgba(0,0,0,0)',margin:{l:50,r:20,t:10,b:45},
    xaxis:{title:'Re{m}', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
    yaxis:{title:'Im{m}', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO}}, {responsive:true});
}

function render(){
  updateDisplays(); clampTauRFMax();
  const M0=1; // hard-coded
  const alpha=Number(els.alpha.value);
  const TRms=Number(els.TR.value), tauRFms=Number(els.tauRF.value);
  const T1=Number(els.T1.value), T2=Number(els.T2.value);
  const phi=Number(els.phi.value), span=Number(els.fspan.value);

  // RF plot
  const rf=computeRFSeries3(TRms,tauRFms,alpha,phi);
  const yPad=Math.max(0.25,0.15*Math.abs(rf.amp_uT));
  const maxAmp=Math.max(Math.abs(rf.amp_uT),0.5);
  Plotly.react(els.plotRF,
    [{x:rf.t,y:rf.bx,name:'B1x (μT)',type:'scatter',mode:'lines',line:{shape:'hv'}},
     {x:rf.t,y:rf.by,name:'B1y (μT)',type:'scatter',mode:'lines',line:{shape:'hv'}}],
    {paper_bgcolor:'rgba(0,0,0,0)',plot_bgcolor:'rgba(0,0,0,0)',margin:{l:60,r:20,t:12,b:45},
     xaxis:{title:'Time (ms)',range:[rf.tStart,rf.tEnd], showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
     yaxis:{title:'B1 (μT)',range:[-(maxAmp+yPad),(maxAmp+yPad)], showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
     shapes:[
       {type:'rect',xref:'x',yref:'paper',x0:rf.centers[0]-rf.tauRFms/2,x1:rf.centers[0]+rf.tauRFms/2,y0:0,y1:1,fillcolor:'rgba(100,160,255,.1)',line:{width:0}},
       {type:'rect',xref:'x',yref:'paper',x0:rf.centers[1]-rf.tauRFms/2,x1:rf.centers[1]+rf.tauRFms/2,y0:0,y1:1,fillcolor:'rgba(200,200,255,.1)',line:{width:0}},
       {type:'rect',xref:'x',yref:'paper',x0:rf.centers[2]-rf.tauRFms/2,x1:rf.centers[2]+rf.tauRFms/2,y0:0,y1:1,fillcolor:'rgba(160,255,160,.1)',line:{width:0}},
       {type:'line',xref:'x',yref:'paper',x0:0,x1:0,y0:0,y1:1,line:{dash:'dot',width:1,color:ZERO}}],
     annotations:[
       {xref:'x',yref:'paper',x:rf.centers[0],y:1.08,text:'φₙ₋₁',showarrow:false,font:{size:12,color:'#cfd2d8'}},
       {xref:'x',yref:'paper',x:rf.centers[1],y:1.08,text:'φₙ',showarrow:false,font:{size:12,color:'#cfd2d8'}},
       {xref:'x',yref:'paper',x:rf.centers[2],y:1.08,text:'φₙ₊₁',showarrow:false,font:{size:12,color:'#cfd2d8'}}
     ]});

  // Lineshape
  const TRs=TRms/1000, fmax=(span/(2*TRs));
  const freqs=linspace(-fmax,fmax,1001);
  const params=computeParams(TRms,T1,T2,alpha,M0);
  const res=computeSSFP(freqs,phi,params);
  const traces=[];
  if(els.showMag.checked) traces.push({x:freqs,y:res.mag,name:'|m|',type:'scatter',mode:'lines'});
  if(els.showReal.checked) traces.push({x:freqs,y:res.real,name:'Re',type:'scatter',mode:'lines'});
  if(els.showImag.checked) traces.push({x:freqs,y:res.imag,name:'Im',type:'scatter',mode:'lines'});
  if(els.showPhase.checked) traces.push({x:freqs,y:res.phs.map(v=>v/Math.PI),name:'phase/π',type:'scatter',mode:'lines',yaxis:'y2'});
  const layout1={paper_bgcolor:'rgba(0,0,0,0)',plot_bgcolor:'rgba(0,0,0,0)',margin:{l:60,r:60,t:10,b:45},
                 xaxis:{title:'Off-resonance f (Hz)', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
                 yaxis:{title:'Signal', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO}};
  if(els.showPhase.checked) layout1.yaxis2={overlaying:'y',side:'right',title:'phase / π', showgrid:false, zerolinecolor:ZERO};
  Plotly.react(els.plot1, traces, layout1);

  // Heat map
  const aMax=90, nA=60;
  const aList=linspace(0.1,aMax,nA);
  const Z=[];
  for(let k=0;k<aList.length;k++){ const p=computeParams(TRms,T1,T2,aList[k],M0); const r=computeSSFP(freqs,phi,p); Z.push(r.mag); }
  Plotly.react(els.plot2, [{z:Z,x:freqs,y:aList,type:'heatmap',colorscale:'Viridis'}],
    {paper_bgcolor:'rgba(0,0,0,0)',plot_bgcolor:'rgba(0,0,0,0)',margin:{l:60,r:10,t:10,b:45},
     xaxis:{title:'Off-resonance f (Hz)', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
     yaxis:{title:'Flip angle α (deg)', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO}});

  // Ellipse (robust)
  const phiSweep=linspace(0.1,359.9,721);
  const X=[], Y=[];
  for(let i=0;i<phiSweep.length;i++){
    const pt=computeM_for_phi(0.0, phiSweep[i], params);
    if(Number.isFinite(pt[0]) && Number.isFinite(pt[1])){ X.push(pt[0]); Y.push(pt[1]); }
  }
  let xmin=-1, xmax=1, ymin=-1, ymax=1;
  let dot=[0,0];
  els.ellipseMsg.textContent='';
  if(X.length>=4){
    xmin=Math.min(...X); xmax=Math.max(...X);
    ymin=Math.min(...Y); ymax=Math.max(...Y);
    const xr=xmax-xmin, yr=ymax-ymin;
    const padx=(xr||1)*0.05, pady=(yr||1)*0.05;
    xmin-=padx; xmax+=padx; ymin-=pady; ymax+=pady;
    dot=computeM_for_phi(0.0, phi, params);
    if(!Number.isFinite(dot[0]) || !Number.isFinite(dot[1])) dot=[0,0];
  } else {
    els.ellipseMsg.textContent='Ellipse not shown for this parameter set.';
  }
  const ELLIPSEc=getComputedStyle(document.documentElement).getPropertyValue('--ellipse') || '#666666';
  const DOTc=getComputedStyle(document.documentElement).getPropertyValue('--dot') || '#ff7a00';
  Plotly.react(els.plotEllipse,
    [{x:X,y:Y,type:'scatter',mode:'lines',line:{width:2,color:ELLIPSEc.trim()},hoverinfo:'skip'},
     {x:[dot[0]],y:[dot[1]],type:'scatter',mode:'markers',marker:{size:10,color:DOTc.trim()},hoverinfo:'skip'}],
    {paper_bgcolor:'rgba(0,0,0,0)',plot_bgcolor:'rgba(0,0,0,0)',margin:{l:50,r:20,t:10,b:45},
     xaxis:{title:'Re{m}',range:[xmin,xmax], showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
     yaxis:{title:'Im{m}',range:[ymin,ymax], showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
     showlegend:false});
}

function bindInputs(){
  // removed M0
  ['alpha','TR','tauRF','T1','T2','phi','fspan','showMag','showReal','showImag','showPhase']
    .forEach(id => document.getElementById(id).addEventListener('input', render));
}

document.addEventListener('DOMContentLoaded', async ()=>{
  bindEls();
  const ok=await ensurePlotly();
  if(!ok) return;
  // Initial empty figures, then render
  Plotly.newPlot(els.plotRF, [], {});
  Plotly.newPlot(els.plot1, [], {});
  Plotly.newPlot(els.plot2, [], {});
  Plotly.newPlot(els.plotEllipse, [], {});
  bindInputs();
  render();
});
</script>
</body>
</html>
