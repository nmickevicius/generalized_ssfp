<!DOCTYPE html>
<html lang="en">
\1
<style>

/* --- Force Plotly text (axis titles, ticks, legend) to pure white --- */
.js-plotly-plot text,
.js-plotly-plot .legend text,
.js-plotly-plot .g-legend text,
.js-plotly-plot .g-xtitle text,
.js-plotly-plot .g-ytitle text,
.js-plotly-plot .xtick text,
.js-plotly-plot .ytick text,
.js-plotly-plot .legendtext {
  fill: #ffffff !important;
}
/* Some builds set stroke on text; neutralize it */
.js-plotly-plot text { stroke: none !important; }

</style>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Two-Pool SSFP Explorer</title>
<script src="plotly.min.js"></script>
<script>
  window.MathJax = {
    tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$','$$'], ['\\[','\\]']], processEscapes: true },
    options: { renderActions: { addMenu: [] } }, svg: { fontCache: 'global' }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<style>
  :root{--bg:#121212;--panel:#1a1a1a;--ink:#e8e8ea;--muted:#a8abb2;--radius:16px;}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial;}
  header{padding:20px 16px 8px;text-align:center;}
  .title{font-weight:800;font-size:clamp(22px,3.5vw,36px);}
  .subtitle{color:var(--muted); font-size:14px; margin-top:6px;}
  .wrap{display:grid;gap:16px;grid-template-columns:340px 1fr;padding:14px;}
  @media(max-width:1100px){.wrap{grid-template-columns:1fr;}}
  .card{background:var(--panel);border-radius:var(--radius);border:1px solid rgba(255,255,255,.06);}
  .pad{padding:14px 14px 10px;}
  .section-title{font-weight:700;margin:4px 0 8px;}
  .hr{height:1px;background:rgba(255,255,255,.08);margin:10px 0;border:none;}
  .controls label{display:block;font-size:12px;color:var(--muted);margin:10px 0 4px;}
  .controls input[type="range"]{width:100%;}
  .switch{display:inline-flex;align-items:center;gap:6px;background:#141414;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.1);font-size:12px;margin-right:8px;}
  .plot{height:420px;} .plotRF{height:300px;}
  .grid-spectrum-ellipse{display:grid;grid-template-columns:1.6fr 1fr;gap:12px;align-items:stretch;}
  @media(max-width:1100px){.grid-spectrum-ellipse{grid-template-columns:1fr;}}
  .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;color:#a0f0b3;}
  .msg{font-size:12px;color:var(--muted);margin-top:6px;}
  .warn{background:rgba(255,204,102,.1);border:1px solid rgba(255,204,102,.35);color:#ffdca3;padding:8px 12px;margin:8px 14px;border-radius:12px;display:none}
  .equations{font-size:14px; line-height:1.5}
  .equations code{font-family:ui-monospace,Menlo,Consolas,monospace;}
  .note{color:var(--muted); font-size:12px; margin-top:6px}
  .controls { position: sticky; top: 12px; align-self: start; max-height: calc(100vh - 24px); overflow: auto; -webkit-overflow-scrolling: touch; }
  :root { --grid: rgba(170,170,170,0.28); --zero: rgba(170,170,170,0.45);
          --ellipse:#666666; --dot:#ff7a00; }
</style>

<!-- Mobile-only layout fixes: keep desktop unchanged -->
<style>
@media (max-width: 700px) {
  /* Make sure nothing blocks scrolling past the controls */
  html, body { height: auto; overflow: auto; }
  
  /* Turn off sticky panel on phones so content isn't trapped underneath */
  .controls {
    position: static !important;
    top: auto !important;
    max-height: none !important;
    overflow: visible !important;
    box-shadow: none;
  }

  /* Provide some breathing room */
  .wrap { gap: 12px; padding: 10px; }
  header { padding-bottom: 6px; }

  /* Expander styling (created by JS) */
  details.mobile-controls {
    border: 1px solid rgba(0,0,0,0.08);
    border-radius: 12px;
    background: rgba(0,0,0,0.02);
    padding: 8px 10px;
  }
  details.mobile-controls > summary {
    list-style: none;
    cursor: pointer;
    font-weight: 600;
    padding: 6px 4px;
    user-select: none;
  }
  details.mobile-controls > summary::-webkit-details-marker { display: none; }
  details.mobile-controls[open] { background: rgba(0,0,0,0.03); }

  /* Make long equations and code horizontally scrollable */
  .equations, .equations code, pre, code {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }

  /* Reasonable default chart heights on phones */
  .plot   { height: 300px !important; min-height: 240px; }
  .plotRF { height: 220px !important; min-height: 200px; }
  #plot2, #plotEllipse { height: 360px !important; min-height: 260px; }

  /* Tighten grid gaps if any */
  .grid-spectrum-ellipse { gap: 10px; }
}

/* Extra narrow */
@media (max-width: 380px) {
  .plot   { height: 260px !important; }
  .plotRF { height: 200px !important; }
  #plot2, #plotEllipse { height: 300px !important; }
}
</style>

</head>
<body>
<header>
  <div class="title">Analytical Two-Pool SSFP</div>
  <div class="subtitle">Explore the coherent signal and its DFT components.</div>
</header>

<div id="warn" class="warn"></div>

<div class="wrap">
  <div class="card pad controls">
    <div class="section-title">Parameters</div>

    <label>Flip angle α (deg)</label>
    <input type="range" id="alpha" min="0" max="120" step="0.5" value="35" />
    <div><span class="kbd" id="alphaDisplay">35°</span></div>

    <label>TR (ms)</label>
    <input type="range" id="TR" min="2" max="12" step="0.1" value="4" />
    <div><span class="kbd" id="TRDisplay">4.0 ms</span></div>

    <label>RF pulse duration τ<sub>RF</sub> (ms)</label>
    <input type="range" id="tauRF" min="0.05" max="3.8" step="0.01" value="0.50" />
    <div><span class="kbd" id="tauRFDisplay">0.50 ms</span></div>

    <label>T<sub>1,f</sub> (ms)</label>
    <input type="range" id="T1f" min="100" max="3000" step="10" value="1000" />
    <div><span class="kbd" id="T1fDisplay">1000 ms</span></div>

    <label>T<sub>1,r</sub> (ms)</label>
    <input type="range" id="T1r" min="100" max="3000" step="10" value="1200" />
    <div><span class="kbd" id="T1rDisplay">1200 ms</span></div>

    <label>T<sub>2</sub> (ms)</label>
    <input type="range" id="T2" min="10" max="300" step="1" value="80" />
    <div><span class="kbd" id="T2Display">80 ms</span></div>

    <label>Pool fraction F</label>
    <input type="range" id="F" min="0.001" max="0.5" step="0.001" value="0.10" />
    <div><span class="kbd" id="FDisplay">0.100</span></div>

    <label>k<sub>f</sub> (ms<sup>-1</sup>)</label>
    <input type="range" id="kf" min="0.0001" max="0.01" step="0.0001" value="0.0010" />
    <div><span class="kbd" id="kfDisplay">0.0010 ms⁻¹</span></div>

    <label>RF phase increment φ (deg)</label>
    <input type="range" id="phi" min="0" max="360" step="1" value="180" />
    <div><span class="kbd" id="phiDisplay">180°</span></div>

    <label>Frequency range (×1/TR bandwidth)</label>
    <input type="range" id="fspan" min="0.2" max="3.0" step="0.1" value="1.0" />
    <div><span class="kbd" id="fspanDisplay">±0.50/TR</span></div>

    <div class="hr"></div>
    <div class="section-title">Display</div>
    <label class="switch"><input type="checkbox" id="showMag" checked /> |m⁺|</label>
    <label class="switch"><input type="checkbox" id="showReal" /> Re</label>
    <label class="switch"><input type="checkbox" id="showImag" /> Im</label>
    <label class="switch"><input type="checkbox" id="showPhase" checked /> Phase</label>
  </div>

  <div class="card pad">
    <div class="section-title">Two-Pool SSFP Signal</div>
    <div class="equations">
      The general form for the steady-state magnetization immediately after an RF pulse in coherent (i.e., balanced) SSFP sequences is given by:
      $$
      m^+ = A\,\frac{1 - E_2 e^{i\varphi}}{B\cos\varphi + C}
      $$

      Noting that $m^+$ above is a periodic function of $\varphi$, it can be reprented as a Fourier series: 
      $$
      m^+ = \sum_{k=-\infty}^{+\infty} S_{k} e^{i k \varphi}
      $$
      where $S_k$ are the individual "components", "modes", or "configurations" of the SSFP signal. For example, the $k=0$ mode corresponds to the free induction decay signal (SSFP-FID) and the $k=-1$ mode corresponds to the SSFP-Echo signal. The general form for the the SSFP components is given by: 
      $$
      \begin{aligned}
      S_0 &= \frac{A}{C}\left(u_0 - E_2 u_1 \right)\\
      S_{-1} &= \frac{A}{C}\left(u_0 E_2 - u_1 \right)\\
      S_k &= \begin{cases}
        \left(\frac{u_1}{u_0}\right)^k S_0 \quad \quad &k \geq 0\\
        \left(\frac{u_1}{u_0}\right)^{|k|-1} S_{-1} \quad \quad &k < 0
    \end{cases}
      \end{aligned}
      $$
      with 
      $$
      \begin{aligned}
      u_0 &= \frac{C}{\sqrt{C^2 - B^2}}\\
      u_1 &= \frac{C}{B}(1 - u_0)
      \end{aligned}
      $$


      As derived in the article for two-pool systems with magnetization transfer, the coefficients $A$, $B$, and $C$ are given by the following: 
      $$
      A=\beta_5\sin\alpha,\quad B=\beta_3,\quad C=\beta_4 
      $$

      where
      $$
      \begin{aligned}
      \beta_1 &= 1 + F - f_w E_{1,r} (F + f_k),\\
      \beta_2 &= 1 + f_k\!\left(F - f_w E_{1,r}(F+1)\right),\\
      \beta_3 &= E_{2}\left(\beta_2 E_{1,f} - \beta_1\right)\left(1 + \cos \alpha\right),\\
      \beta_4 &= \beta_1 - \beta_2 E_{1,f}\cos \alpha - \left(\beta_2 E_{1,f} - \beta_1 \cos \alpha\right)E_{2}^2,\\
      \beta_5 &= M_{0,f}\,\beta_2\left(1 - E_{1,f}\right) + M_{0,r}\left(1 - E_{1,r}\right)\left(1 - f_k\right)
      \end{aligned}
      $$

      Magnetization transfer systems are parameterized by the free pool $T_2$ relaxation rate, free pool $T_{1,f}$ relaxation rate, the restricted pool $T_{1,r}$ relaxation rate, the restricted pool size $F := M_{0,r}/M_{0,f}$, the exchange rate from and to the free pool $k_f$ and $k_r$, and the off-resonance value $\Delta f$. The interaction between these tissue parameters and the SSFP acquisition parameters such as the flip angle $\alpha$, repetition time $TR$, restricted pool saturation rate from the excitation pulse $\langle W(\Delta\rightarrow0)\rangle$, RF pulse duration $\tau_{RF}$, and the linear shot-to-shot RF phase increment $\phi$. The following definitions were used in the above expressions: 

      $$
      \begin{aligned}
      E_2 &= e^{-TR/T_2} \\
      E_{1,f} &= e^{-TR/T_{1,f}}\\
      E_{1,r} &= e^{-TR/T_{1,r}}\\
      \varphi &= 2\pi \Delta f \cdot TR \\
      f_k &= e^{-(k_r + k_f)\cdot TR}\\
      f_w &= e^{\langle W(\Delta\rightarrow0)\rangle \cdot \tau_{RF}}
      \end{aligned}
      $$

      <!-- <div class="note">We take \(\\varphi = \\phi - 2\\pi f\\,TR\\). The DFT below is computed from \(m^+(\\varphi)\\) sampled at 128 evenly spaced RF phases with \(f=0\\).</div> -->
    </div>
    <div class="hr"></div>

    <div class="section-title">RF Pulses for Three TR Periods </div>
    <div id="plotRF" class="plotRF"></div>
    <div class="hr"></div>


    <div class="hr"></div>

    <div class="section-title">$m^+$ Off-Resonance Profile</div>
    <div id="plot1" class="plot"></div>

    <div class="section-title">DFT of $m^+$ & complex-plane ellipse</div>
    <div class="grid-spectrum-ellipse">
      <div>
        <div style="font-size:13px;color:var(--muted);margin-bottom:6px;">Magnitude of DFT of $m^+$ across 128 $\phi$ values (zoomed to k∈[-5,5])</div>
        <div id="plot2" class="plot" style="height:460px;"></div>
      </div>
      <div>
        <div style="font-size:13px;color:var(--muted);margin-bottom:6px;">Ellipse of steady-state $m^+$ (varying RF phase $\phi$)</div>
        <div id="plotEllipse" class="plot" style="height:460px;"></div>
        <div id="ellipseMsg" class="msg"></div>
      </div>
    </div>
  </div>
</div>

<script>
"use strict";
const warnEl = document.getElementById('warn');
function warn(msg){ warnEl.textContent = msg; warnEl.style.display = 'block'; }

function ensurePlotly(){
  return new Promise((resolve)=>{
    if(window.Plotly){ return resolve(true); }
    const s=document.createElement('script');
    s.src='https://cdn.plot.ly/plotly-2.35.2.min.js';
    s.onload=()=>resolve(true);
    s.onerror=()=>{ warn('Could not load Plotly. Place plotly.min.js next to this HTML.'); resolve(false); };
    document.head.appendChild(s);
  });
}

const GRID = getComputedStyle(document.documentElement).getPropertyValue('--grid') || 'rgba(170,170,170,0.28)';
const ZERO = getComputedStyle(document.documentElement).getPropertyValue('--zero') || 'rgba(170,170,170,0.45)';
const ELLIPSE = getComputedStyle(document.documentElement).getPropertyValue('--ellipse') || '#666666';
const DOT = getComputedStyle(document.documentElement).getPropertyValue('--dot') || '#ff7a00';

const rad = d => d * Math.PI / 180;

// ----- Two-pool parameters (convert ms and ms^-1 to SI) -----
function computeParams2(TRms, T1f_ms, T1r_ms, T2_ms, alphaDeg, F, kf_per_ms, tauRF_ms){
  const TR = TRms/1000;
  const T1f = T1f_ms/1000, T1r = T1r_ms/1000, T2 = T2_ms/1000;
  const a = rad(alphaDeg);
  const E1f = Math.exp(-TR/Math.max(T1f,1e-12));
  const E1r = Math.exp(-TR/Math.max(T1r,1e-12));
  const E2  = Math.exp(-TR/Math.max(T2,1e-12));
  const kf_s = kf_per_ms*1000.0;             // ms^-1 -> s^-1
  const kr_s = kf_s/Math.max(F,1e-12);       // s^-1
  const fk   = Math.exp(-(kr_s + kf_s)*TR);
  const G0   = 15.1e-6;
  const tauRF = Math.max(tauRF_ms/1000, 1e-9);
  const fw   = Math.exp(-(Math.PI * a*a * G0) / tauRF);
  return {TR, T1f, T1r, T2, a, E1f, E1r, E2, F, kf_s, kr_s, fk, fw};
}

// m⁺ from provided formula; ϕ = φ - 2π f TR
function compute_mplus(freqs, phiDeg, p){
  const phi = rad(phiDeg);
  const {TR, E1f, E1r, E2, a, F, fk, fw} = p;
  const M0f = 1.0, M0r = F;
  const c = Math.cos(a);

  const beta1 = 1 + F - fw*E1r*(F + fk);
  const beta2 = 1 + fk*(F - fw*E1r*(F+1));
  const beta3 = E2*(beta2*E1f - beta1)*(1 + c);
  const beta4 = beta1 - beta2*E1f*c - (beta2*E1f - beta1*c)*E2*E2;
  const beta5 = M0f*beta2*(1 - E1f) + M0r*(1 - E1r)*(1 - fk);

  const A = beta5 * Math.sin(a), B = beta3, C = beta4;

  const mag=[], real=[], imag=[], phs=[];
  for(let i=0;i<freqs.length;i++){
    const theta = 2*Math.PI*freqs[i]*p.TR;
    const varphi = phi - theta;
    const cphi = Math.cos(varphi), sphi = Math.sin(varphi);
    const num_r = A * (1 - p.E2*cphi);
    const num_i = A * ( - p.E2*sphi);
    const den = B*cphi + C; // real scalar
    const mr = num_r/den, mi = num_i/den;
    real[i]=mr; imag[i]=mi; mag[i]=Math.hypot(mr,mi); phs[i]=Math.atan2(mi,mr);
  }
  return {mag,real,imag,phs};
}

function computeM_for_phi(phiDeg, p){
  // ellipse at f=0 while sweeping φ
  const M0f = 1.0, M0r = p.F;
  const c = Math.cos(p.a);

  const beta1 = 1 + p.F - p.fw*p.E1r*(p.F + p.fk);
  const beta2 = 1 + p.fk*(p.F - p.fw*p.E1r*(p.F+1));
  const beta3 = p.E2*(beta2*p.E1f - beta1)*(1 + c);
  const beta4 = beta1 - beta2*p.E1f*c - (beta2*p.E1f - beta1*c)*p.E2*p.E2;
  const beta5 = M0f*beta2*(1 - p.E1f) + M0r*(1 - p.E1r)*(1 - p.fk);
  const A = beta5 * Math.sin(p.a), B = beta3, C = beta4;

  const varphi = rad(phiDeg);
  const cphi = Math.cos(varphi), sphi = Math.sin(varphi);
  const num_r = A * (1 - p.E2*cphi);
  const num_i = A * ( - p.E2*sphi);
  const den = B*cphi + C;
  return [num_r/den, num_i/den];
}

// --- NEW: DFT of m+(φ) across 128 phases (f=0) ---
function analyticSk(p){
  // Computes S_-1 (cyan), S_0 (orange), S_+1 (pink) using provided formulas.
  // Uses |C^2 - B^2| inside sqrt to keep u0 real for plotting; handles small |B| with epsilon.
  const c = Math.cos(p.a);
  const beta1 = 1 + p.F - p.fw*p.E1r*(p.F + p.fk);
  const beta2 = 1 + p.fk*(p.F - p.fw*p.E1r*(p.F+1));
  const B = p.E2*(beta2*p.E1f - beta1)*(1 + c);
  const C = beta1 - beta2*p.E1f*c - (beta2*p.E1f - beta1*c)*p.E2*p.E2;
  const A = ( (1*beta2*(1 - p.E1f)) + (p.F*(1 - p.E1r)*(1 - p.fk)) ) * Math.sin(p.a); // M0f=1, M0r=F
  const E2 = p.E2;

  const denomAbs = Math.abs(C*C - B*B);
  const u0 = C / Math.sqrt(denomAbs + 1e-30);
  const u1 = (Math.abs(B) < 1e-12) ? 0 : (C / B) * (1 - u0);

  const S0  = (A/C) * (u0 - E2*u1);
  const Sm1 = (A/C) * (u0*E2 - u1);
  const Sp1 = (A/C) * (u0 - E2*u1) * (u1/u0);

  // Return magnitudes for plotting against |DFT{m+}|
  return {Sm1: Math.abs(Sm1), S0: Math.abs(S0), Sp1: Math.abs(Sp1)};
}
function dftSpectrum128(p){


  const N=128;
  const mRe=new Array(N), mIm=new Array(N);
  for(let n=0;n<N;n++){
    const phiDeg = n*(360/N);
    const [re,im]=computeM_for_phi(phiDeg, p);
    mRe[n]=re; mIm[n]=im;
  }
  // DFT X[k] = sum_n m[n] * exp(-i 2π k n / N), k in -64..+63
  const Kmin=-64, Kmax=63;
  const ks=[], mag=[];
  for(let k=Kmin; k<=Kmax; k++){
    let Sr=0, Si=0;
    for(let n=0;n<N;n++){
      const ang = 2*Math.PI*k*n/N;
      const ca=Math.cos(ang), sa=Math.sin(ang);
      // (re + i im) * (ca + i sa) = (re*ca - im*sa) + i(re*sa + im*ca)
      Sr += mRe[n]*ca - mIm[n]*sa;
      Si += mRe[n]*sa + mIm[n]*ca;
    }
    ks.push(k);
    mag.push(Math.hypot(Sr,Si)/N); // normalized magnitude
  }
  return {ks, mag};
}

function computeRFSeries3(TRms, tauRFms, alphaDeg, phiIncDeg){
  const halfSpan=1.5*TRms, tStart=-halfSpan, tEnd=+halfSpan;
  const N=2400, t=Array.from({length:N}, (_,i)=>tStart + i*(tEnd-tStart)/(N-1));
  const centers=[-TRms,0,TRms];
  const phi_n=0, phi_nm1=(phi_n - phiIncDeg)%360, phi_np1=(phi_n + phiIncDeg)%360;
  const phiList=[phi_nm1, phi_n, phi_np1];
  const gamma=2*Math.PI*42.58e6; // rad/s/T
  const tau_s=Math.max(1e-9, tauRFms/1000);
  const alpha_rad=rad(alphaDeg);
  const amp_T=alpha_rad/(gamma*tau_s);
  const amp_uT=amp_T*1e6;
  const bx=new Array(N).fill(0), by=new Array(N).fill(0);
  const halfW=tauRFms/2;
  for(let i=0;i<N;i++){
    const ti=t[i];
    for(let k=0;k<3;k++){
      const c=centers[k];
      if(ti>=(c-halfW) && ti<(c+halfW)){
        const ph=rad(phiList[k]);
        bx[i]=amp_uT*Math.cos(ph); by[i]=amp_uT*Math.sin(ph); break;
      }
    }
  }
  return {t,bx,by,centers,tStart,tEnd,amp_uT,tauRFms};
}

const els = {};
function bindEls(){
  ['alpha','alphaDisplay','TR','TRDisplay','tauRF','tauRFDisplay',
   'T1f','T1fDisplay','T1r','T1rDisplay','T2','T2Display',
   'F','FDisplay','kf','kfDisplay',
   'phi','phiDisplay','fspan','fspanDisplay','showMag','showReal','showImag','showPhase']
    .forEach(id => els[id]=document.getElementById(id));
  ['plotRF','plot1','plot2','plotEllipse','ellipseMsg'].forEach(id => els[id]=document.getElementById(id));
}

function clampTauRFMax(){
  const TRms=Number(els.TR.value);
  const maxVal=Math.max(0.05, TRms - 0.2);
  els.tauRF.max=String(maxVal);
  if(Number(els.tauRF.value)>maxVal) els.tauRF.value=String(maxVal.toFixed(2));
}

function updateDisplays(){
  els.alphaDisplay.textContent=`${Number(els.alpha.value).toFixed(1)}°`;
  els.TRDisplay.textContent=`${Number(els.TR.value).toFixed(1)} ms`;
  els.tauRFDisplay.textContent=`${Number(els.tauRF.value).toFixed(2)} ms`;
  els.T1fDisplay.textContent=`${Number(els.T1f.value)} ms`;
  els.T1rDisplay.textContent=`${Number(els.T1r.value)} ms`;
  els.T2Display.textContent=`${Number(els.T2.value)} ms`;
  els.FDisplay.textContent=`${Number(els.F.value).toFixed(3)}`;
  els.kfDisplay.textContent=`${Number(els.kf.value).toFixed(4)} ms⁻¹`;
  els.phiDisplay.textContent=`${Number(els.phi.value)}°`;
  els.fspanDisplay.textContent=`±${(0.5*Number(els.fspan.value)).toFixed(2)}/TR`;
}

function initFigures(){
  Plotly.newPlot(els.plotRF, [], {paper_bgcolor:'rgba(0,0,0,0)',plot_bgcolor:'rgba(0,0,0,0)',margin:{l:60,r:20,t:12,b:45},
    xaxis:{title:'Time (ms)', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
    yaxis:{title:'B1 (μT)', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO}}, {responsive:true})
;try{Plotly.relayout(els.plotRF, {
  font: {color: '#ffffff'},
  legend: {font: {color: '#ffffff'}},
  'xaxis.title.font.color': '#ffffff',
  'yaxis.title.font.color': '#ffffff',
  'xaxis.tickfont.color': '#ffffff',
  'yaxis.tickfont.color': '#ffffff',
  'xaxis2.title.font.color': '#ffffff',
  'yaxis2.title.font.color': '#ffffff',
  'xaxis2.tickfont.color': '#ffffff',
  'yaxis2.tickfont.color': '#ffffff'
});}catch(e){};
  Plotly.newPlot(els.plot1, [], {paper_bgcolor:'rgba(0,0,0,0)',plot_bgcolor:'rgba(0,0,0,0)',margin:{l:60,r:60,t:10,b:45},
    xaxis:{title:'Off-resonance f (Hz)', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
    yaxis:{title:'Signal', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO}}, {responsive:true})
;try{Plotly.relayout(els.plot1, {
  font: {color: '#ffffff'},
  legend: {font: {color: '#ffffff'}},
  'xaxis.title.font.color': '#ffffff',
  'yaxis.title.font.color': '#ffffff',
  'xaxis.tickfont.color': '#ffffff',
  'yaxis.tickfont.color': '#ffffff',
  'xaxis2.title.font.color': '#ffffff',
  'yaxis2.title.font.color': '#ffffff',
  'xaxis2.tickfont.color': '#ffffff',
  'yaxis2.tickfont.color': '#ffffff'
});}catch(e){};
  Plotly.newPlot(els.plot2, [], {paper_bgcolor:'rgba(0,0,0,0)',plot_bgcolor:'rgba(0,0,0,0)',margin:{l:60,r:10,t:10,b:45},
    xaxis:{title:'SSFP Component Index k', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
    yaxis:{title:'Signal Magnitude', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO}}, {responsive:true})
;try{Plotly.relayout(els.plot2, {
  font: {color: '#ffffff'},
  legend: {font: {color: '#ffffff'}},
  'xaxis.title.font.color': '#ffffff',
  'yaxis.title.font.color': '#ffffff',
  'xaxis.tickfont.color': '#ffffff',
  'yaxis.tickfont.color': '#ffffff',
  'xaxis2.title.font.color': '#ffffff',
  'yaxis2.title.font.color': '#ffffff',
  'xaxis2.tickfont.color': '#ffffff',
  'yaxis2.tickfont.color': '#ffffff'
});}catch(e){};
  Plotly.newPlot(els.plotEllipse, [], {paper_bgcolor:'rgba(0,0,0,0)',plot_bgcolor:'rgba(0,0,0,0)',margin:{l:50,r:20,t:10,b:45},
    xaxis:{title:'Re{m⁺}', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
    yaxis:{title:'Im{m⁺}', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO}}, {responsive:true});
}

function linspace(a,b,n){ const arr=new Array(n), step=(b-a)/(n-1); for(let i=0;i<n;i++) arr[i]=a + i*step; return arr; }

function render(){
  updateDisplays(); clampTauRFMax();

  const alpha=Number(els.alpha.value);
  const TRms=Number(els.TR.value), tauRFms=Number(els.tauRF.value);
  const T1f=Number(els.T1f.value), T1r=Number(els.T1r.value), T2=Number(els.T2.value);
  const F=Number(els.F.value), kf=Number(els.kf.value);
  const phi=Number(els.phi.value), span=Number(els.fspan.value);

  // RF plot
  const rf=computeRFSeries3(TRms,tauRFms,alpha,phi);
  const yPad=Math.max(0.25,0.15*Math.abs(rf.amp_uT));
  const maxAmp=Math.max(Math.abs(rf.amp_uT),0.5);
  Plotly.react(els.plotRF,
    [{x:rf.t,y:rf.bx,name:'B1x (μT)',type:'scatter',mode:'lines',line:{shape:'hv'}},
     {x:rf.t,y:rf.by,name:'B1y (μT)',type:'scatter',mode:'lines',line:{shape:'hv'}}],
    {paper_bgcolor:'rgba(0,0,0,0)',plot_bgcolor:'rgba(0,0,0,0)',margin:{l:60,r:20,t:12,b:45},
     xaxis:{title:'Time (ms)',range:[rf.tStart,rf.tEnd], showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
     yaxis:{title:'B1 (μT)',range:[-(maxAmp+yPad),(maxAmp+yPad)], showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
     shapes:[
       {type:'rect',xref:'x',yref:'paper',x0:rf.centers[0]-rf.tauRFms/2,x1:rf.centers[0]+rf.tauRFms/2,y0:0,y1:1,fillcolor:'rgba(100,160,255,.1)',line:{width:0}},
       {type:'rect',xref:'x',yref:'paper',x0:rf.centers[1]-rf.tauRFms/2,x1:rf.centers[1]+rf.tauRFms/2,y0:0,y1:1,fillcolor:'rgba(200,200,255,.1)',line:{width:0}},
       {type:'rect',xref:'x',yref:'paper',x0:rf.centers[2]-rf.tauRFms/2,x1:rf.centers[2]+rf.tauRFms/2,y0:0,y1:1,fillcolor:'rgba(160,255,160,.1)',line:{width:0}},
       {type:'line',xref:'x',yref:'paper',x0:0,x1:0,y0:0,y1:1,line:{dash:'dot',width:1,color:ZERO}}],
     annotations:[
       {xref:'x',yref:'paper',x:rf.centers[0],y:1.08,text:'ϕₙ₋₁',showarrow:false,font:{size:12,color:'#cfd2d8'}},
       {xref:'x',yref:'paper',x:rf.centers[1],y:1.08,text:'ϕₙ',showarrow:false,font:{size:12,color:'#cfd2d8'}},
       {xref:'x',yref:'paper',x:rf.centers[2],y:1.08,text:'ϕₙ₊₁',showarrow:false,font:{size:12,color:'#cfd2d8'}}
     ]});

  // Lineshape with new m⁺
  const TRs=TRms/1000, fmax=(span/(2*TRs));
  const freqs=linspace(-fmax,fmax,1001);
  const params=computeParams2(TRms,T1f,T1r,T2,alpha,F,kf,tauRFms);
  const res=compute_mplus(freqs,phi,params);
  const traces=[];
  if(els.showMag.checked) traces.push({x:freqs,y:res.mag,name:'|m⁺|',type:'scatter',mode:'lines'});
  if(els.showReal.checked) traces.push({x:freqs,y:res.real,name:'Re',type:'scatter',mode:'lines'});
  if(els.showImag.checked) traces.push({x:freqs,y:res.imag,name:'Im',type:'scatter',mode:'lines'});
  if(els.showPhase.checked) traces.push({x:freqs,y:res.phs.map(v=>v/Math.PI),name:'phase/π',type:'scatter',mode:'lines',yaxis:'y2'});
  const layout1={paper_bgcolor:'rgba(0,0,0,0)',plot_bgcolor:'rgba(0,0,0,0)',margin:{l:60,r:60,t:10,b:45},
                 xaxis:{title:'Off-resonance f (Hz)', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
                 yaxis:{title:'Signal', showgrid:true, gridcolor:GRID, zerolinecolor:ZERO}};
  if(els.showPhase.checked) layout1.yaxis2={overlaying:'y',side:'right',title:'phase / π', showgrid:false, zerolinecolor:ZERO};
  Plotly.react(els.plot1, traces, layout1);

  // --- NEW: Spectrum plot on the left (replacing heatmap) ---
  const spec = dftSpectrum128(params); // f=0 inside
  // Zoom to k in [-5,5]
  const xs=[], ys=[];
  for(let i=0;i<spec.ks.length;i++){
    const k=spec.ks[i];
    if(k>=-5 && k<=5){ xs.push(k); ys.push(spec.mag[i]); }
  }
  // Get magnitudes at k=-1,0,+1
  const Sk = analyticSk(params);
  const lineX = [-5, 5];
  // we'll draw horizontal lines at these y values
  const y_m1_line = [Sk.Sm1, Sk.Sm1];
  const y_0_line  = [Sk.S0,  Sk.S0 ];
  const y_p1_line = [Sk.Sp1, Sk.Sp1];

  function magAt(k){
    const idx = spec.ks.indexOf(k);
    return idx>=0 ? spec.mag[idx] : NaN;
  }
  const m_km1 = magAt(-1), m_k0 = magAt(0), m_kp1 = magAt(1);

  Plotly.react(els.plot2,
    [
      {x: xs, y: ys, type:'scatter', mode:'lines', name:'|DFT{m⁺}|', line:{width:2}},
      // analytic horizontal lines
      {x: lineX, y: y_m1_line, type:'scatter', mode:'lines', line:{width:2}, hoverinfo:'none', name:'S_-1', marker:{color:'cyan'}},
      {x: lineX, y: y_0_line,  type:'scatter', mode:'lines', line:{width:2}, hoverinfo:'none', name:'S_0', marker:{color:'orange'}},
      {x: lineX, y: y_p1_line, type:'scatter', mode:'lines', line:{width:2}, hoverinfo:'none', name:'S_+1', marker:{color:'hotpink'}},
      // sampled DFT markers
      {x: [-1], y: [m_km1], type:'scatter', mode:'markers', marker:{size:16, color:'cyan'}, name:'k=-1'},
      {x: [ 0], y: [m_k0 ], type:'scatter', mode:'markers', marker:{size:16, color:'orange'}, name:'k=0'},
      {x: [ 1], y: [m_kp1], type:'scatter', mode:'markers', marker:{size:16, color:'hotpink'}, name:'k=+1'}
    ],
    {
      paper_bgcolor:'rgba(0,0,0,0)',
      plot_bgcolor:'rgba(0,0,0,0)',
      margin:{l:60,r:10,t:10,b:45},
      xaxis:{title:'SSFP Component Index k', range:[-5,5], dtick:1, showgrid:true, gridcolor:GRID, zeroline:true, zerolinecolor:ZERO},
      yaxis:{title:'Signal Magnitude', showgrid:true, gridcolor:GRID, zeroline:true, zerolinecolor:ZERO},
      showlegend:true
    }
  );

  // Ellipse at f=0 sweeping φ
  const phiSweep=(function(){const arr=[]; for(let d=0.1; d<360; d+=0.5) arr.push(d); return arr;})();
  const X=[], Y=[];
  for(let i=0;i<phiSweep.length;i++){
    const pt=computeM_for_phi(phiSweep[i], params);
    if(Number.isFinite(pt[0]) && Number.isFinite(pt[1])){ X.push(pt[0]); Y.push(pt[1]); }
  }
  let xmin=-1, xmax=1, ymin=-1, ymax=1;
  let dot=[0,0];
  els.ellipseMsg.textContent='';
  if(X.length>=4){
    xmin=Math.min(...X); xmax=Math.max(...X);
    ymin=Math.min(...Y); ymax=Math.max(...Y);
    const xr=xmax-xmin, yr=ymax-ymin;
    const padx=(xr||1)*0.05, pady=(yr||1)*0.05;
    xmin-=padx; xmax+=padx; ymin-=pady; ymax+=pady;
    dot=computeM_for_phi(phi, params);
    if(!Number.isFinite(dot[0]) || !Number.isFinite(dot[1])) dot=[0,0];
  } else {
    els.ellipseMsg.textContent='Ellipse not shown for this parameter set.';
  }
  const ELLIPSEc=getComputedStyle(document.documentElement).getPropertyValue('--ellipse') || '#666666';
  const DOTc=getComputedStyle(document.documentElement).getPropertyValue('--dot') || '#ff7a00';
  Plotly.react(els.plotEllipse,
    [{x:X,y:Y,type:'scatter',mode:'lines',name:'Ellipse',line:{width:2,color:ELLIPSEc.trim()},hoverinfo:'skip'},
     {x:[dot[0]],y:[dot[1]],type:'scatter',name:'Current', mode:'markers',marker:{size:10,color:DOTc.trim()},hoverinfo:'skip'}],
    {paper_bgcolor:'rgba(0,0,0,0)',plot_bgcolor:'rgba(0,0,0,0)',margin:{l:50,r:20,t:10,b:45},
     xaxis:{title:'Re{m⁺}',range:[xmin,xmax], showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
     yaxis:{title:'Im{m⁺}',range:[ymin,ymax], showgrid:true, gridcolor:GRID, zerolinecolor:ZERO},
     showlegend:true});
}

function bindInputs(){
  ['alpha','TR','tauRF','T1f','T1r','T2','F','kf','phi','fspan','showMag','showReal','showImag','showPhase']
    .forEach(id => document.getElementById(id).addEventListener('input', render));
}

document.addEventListener('DOMContentLoaded', async ()=>{
  bindEls();
  const ok=await ensurePlotly();
  if(!ok) return;
  Plotly.newPlot(els.plotRF, [], {})
;try{Plotly.relayout(els.plotRF, {
  font: {color: '#ffffff'},
  legend: {font: {color: '#ffffff'}},
  'xaxis.title.font.color': '#ffffff',
  'yaxis.title.font.color': '#ffffff',
  'xaxis.tickfont.color': '#ffffff',
  'yaxis.tickfont.color': '#ffffff',
  'xaxis2.title.font.color': '#ffffff',
  'yaxis2.title.font.color': '#ffffff',
  'xaxis2.tickfont.color': '#ffffff',
  'yaxis2.tickfont.color': '#ffffff'
});}catch(e){};
  Plotly.newPlot(els.plot1, [], {})
;try{Plotly.relayout(els.plot1, {
  font: {color: '#ffffff'},
  legend: {font: {color: '#ffffff'}},
  'xaxis.title.font.color': '#ffffff',
  'yaxis.title.font.color': '#ffffff',
  'xaxis.tickfont.color': '#ffffff',
  'yaxis.tickfont.color': '#ffffff',
  'xaxis2.title.font.color': '#ffffff',
  'yaxis2.title.font.color': '#ffffff',
  'xaxis2.tickfont.color': '#ffffff',
  'yaxis2.tickfont.color': '#ffffff'
});}catch(e){};
  Plotly.newPlot(els.plot2, [], {})
;try{Plotly.relayout(els.plot2, {
  font: {color: '#ffffff'},
  legend: {font: {color: '#ffffff'}},
  'xaxis.title.font.color': '#ffffff',
  'yaxis.title.font.color': '#ffffff',
  'xaxis.tickfont.color': '#ffffff',
  'yaxis.tickfont.color': '#ffffff',
  'xaxis2.title.font.color': '#ffffff',
  'yaxis2.title.font.color': '#ffffff',
  'xaxis2.tickfont.color': '#ffffff',
  'yaxis2.tickfont.color': '#ffffff'
});}catch(e){};
  Plotly.newPlot(els.plotEllipse, [], {})
;try{Plotly.relayout(els.plotEllipse, {
  font: {color: '#ffffff'},
  legend: {font: {color: '#ffffff'}},
  'xaxis.title.font.color': '#ffffff',
  'yaxis.title.font.color': '#ffffff',
  'xaxis.tickfont.color': '#ffffff',
  'yaxis.tickfont.color': '#ffffff',
  'xaxis2.title.font.color': '#ffffff',
  'yaxis2.title.font.color': '#ffffff',
  'xaxis2.tickfont.color': '#ffffff',
  'yaxis2.tickfont.color': '#ffffff'
});}catch(e){};
  bindInputs();
  render();
});
</script>

<!-- Mobile controls expander + Plotly reflow. Desktop unaffected. -->
<script>
(function() {
  function isPhone() { return window.matchMedia('(max-width: 700px)').matches; }

  function wrapControlsForMobile() {
    if (!isPhone()) return;
    var controls = document.querySelector('.controls');
    if (!controls) return;
    // Already wrapped?
    if (controls.parentElement && controls.parentElement.tagName.toLowerCase() === 'details') return;

    var details = document.createElement('details');
    details.className = 'mobile-controls';
    // Start collapsed so users see charts immediately
    details.open = false;

    var summary = document.createElement('summary');
    summary.textContent = 'Parameters';
    details.appendChild(summary);

    // Move controls inside details
    controls.parentNode.insertBefore(details, controls);
    details.appendChild(controls);
  }

  function unwrapControlsForDesktop() {
    if (isPhone()) return;
    var details = document.querySelector('details.mobile-controls');
    if (!details) return;
    var controls = details.querySelector('.controls');
    if (controls) {
      details.parentNode.insertBefore(controls, details);
    }
    details.remove();
  }

  // Plotly resize helper for crisp charts after layout changes
  var ids = ['plotRF','plot1','plot2','plotEllipse'];
  var plots = [];
  function collectPlots() {
    plots = ids.map(function(id){ return document.getElementById(id); }).filter(Boolean);
  }
  function reflowPlots() {
    if (window.Plotly && plots.length) {
      plots.forEach(function(p){ try { Plotly.Plots.resize(p); } catch(e){} });
    }
  }

  function onReady(fn){
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      setTimeout(fn, 0);
    } else {
      document.addEventListener('DOMContentLoaded', fn);
    }
  }

  onReady(function(){
    wrapControlsForMobile();
    collectPlots();
    setTimeout(reflowPlots, 50);
  });

  var resizeTO;
  window.addEventListener('resize', function(){
    clearTimeout(resizeTO);
    resizeTO = setTimeout(function(){
      if (isPhone()) { wrapControlsForMobile(); }
      else { unwrapControlsForDesktop(); }
      collectPlots();
      reflowPlots();
    }, 120);
  });
})();
</script>

</body>
</html>
